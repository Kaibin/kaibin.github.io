<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Kaibin的技术笔记</title><link href="/" rel="alternate"></link><link href="/feeds/java.atom.xml" rel="self"></link><id>/</id><updated>2014-02-20T00:00:00+08:00</updated><entry><title>Java中的线程中断机制</title><link href="/posts/java_interrupt.html" rel="alternate"></link><updated>2014-02-20T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2014-02-20:posts/java_interrupt.html</id><summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;Java中的许多方法，如 Thread.sleep(), Object.join() 和 Object.wait()等，都可以抛出InterruptedException，这是一个受检异常（checked exception），因此必须在代码中被捕获。通常，当一个方法抛出 InterruptedException，说明这是一个阻塞（blocking）方法，阻塞方法可能因为等不到所等的事件而无法终止，因此令阻塞方法可取消就非常有用。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Java的&lt;strong&gt;线程中断机制&lt;/strong&gt;是一种&lt;strong&gt;协作机制&lt;/strong&gt;，能够使一个线程通知另一个线程，告诉目标线程在合适的情况下终止当前工作。&lt;/p&gt;
&lt;h2&gt;线程中断&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;每个Java线程都有一个用于表示线程中断状态（interrupted status）的标志，其初始值为false。
当在一个线程中，调用了另一个目标线程的 &lt;strong&gt;interrupt( )&lt;/strong&gt;方法时，会发生以下两种情况之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果目标线程正在执行阻塞方法，例如 Thread.sleep( ), Thread.join( ) 或 Object.wait( )，那么它将取消阻塞并抛出InterruptedException，并且，目标线程的interrupted status标志&lt;strong&gt;不会&lt;/strong&gt;被设置为true。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当线程在非阻塞状态下时，interrupt() 只是设置目标线程的中断状态，在被中断的目标线程中运行的代码以后可以轮询中断状态，看看它是否被请求停止正在做的事情。这个中断状态可以通过两种方式读取：    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;interrupted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="err"&gt;#清除当前线程的中断状态，并返回它之前的值&lt;/span&gt;

&lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;isInterrupted&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;     &lt;span class="err"&gt;#返回目标线程的中断状态&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;其中，静态的interrupted( )方法会清除当前线程的interrupted status标志，而非静态的isInterrupted( )方法，通常用于一个线程查询另一个线程的interrupt status标志，不会改变被查询线程的中断标志位。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;em&gt;调用interrupt( )并不意味着立即停止目标线程正在执行的工作，而只是传递了请求中断的消息，通常，中断是实现取消的最合理方式&lt;/em&gt; ——Java并发编程实践&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;以下代码展示一个可取消的线程，通过在另一个线程中调用cancel( )方法就可以退出该线程。可以通过这种生吞中断来达到线程退出的模式来实现可取消的任务。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StoppedThread&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;().&lt;/span&gt;&lt;span class="n"&gt;isInterrupted&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
             &lt;span class="c1"&gt;// ...&lt;/span&gt;
          &lt;span class="p"&gt;}&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;InterruptedException&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
          &lt;span class="cm"&gt;/* Allow thread to exit */&lt;/span&gt;
       &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;cancel&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;interrupt&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;响应中断&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;阻塞方法通常会抛出一个InterruptedException来表示中断异常，通常有两种策略用来处理InterruptedException。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传递异常：一种最容易的策略就是在声明方法时抛出 InterruptedException，将异常向上抛出，由该方法的调用者来处理该异常。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;恢复中断状态：当阻塞方法检测到中断时，它们响应中断时执行的操作包括：清除中断状态，抛出 InterruptedException 并提前结束阻塞。更多情况下，我们需要保留中断发生的证据，以便调用栈中更高层的代码能知道中断并采取进一步的操作。因此，需要通过调用&lt;strong&gt;interrupt( )&lt;/strong&gt; 以 “重新中断” 当前线程来达到恢复中断状态的目的。    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;TaskRunner&lt;/span&gt; &lt;span class="nx"&gt;implements&lt;/span&gt; &lt;span class="nx"&gt;Runnable&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nf"&gt;BlockingQueue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;TaskRunner&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="na"&gt;BlockingQueue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="n"&gt;this.queue&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; 
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;void&lt;/span&gt; &lt;span class="nb"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
        &lt;span class="nx"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;Task&lt;/span&gt; &lt;span class="n"&gt;task&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;queue.take&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;TimeUnit.SECONDS&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                &lt;span class="nx"&gt;task.execute&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;InterruptedException&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; 
            &lt;span class="c1"&gt;// Restore the interrupted status&lt;/span&gt;
            &lt;span class="k"&gt;Thread&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;interrupt&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;对于一些不支持取消但仍可以调用可中断阻塞方法的操作，它们必须在循环中调用这些方法，并在发现中断后重新尝试。在这种情况下，仍然需要保留中断状态，但却是在方法返回前恢复中断状态而不是在捕获InterruptedException时恢复状态。因为大多数可中断的阻塞方法都会在入口处检查中断状态并立即抛出InterruptedException，如果过早地发现并恢复中断，则会引起无线循环。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;NoncancelableTask&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nf"&gt;Task&lt;/span&gt; &lt;span class="nx"&gt;getNextTask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;BlockingQueue&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Task&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;queue&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nb"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;interrupted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nx"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;queue.take&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;InterruptedException&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;interrupted&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="c1"&gt;// fall through and retry&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="nx"&gt;finally&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;interrupted&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;Thread&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;currentThread&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="bp"&gt;.&lt;/span&gt;&lt;span class="nb"&gt;interrupt&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;不可中断的阻塞方法&lt;/h2&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;并非所有的阻塞方法都抛出 InterruptedException。输入和输出流类会阻塞等待 I/O 完成，但是它们不抛出 InterruptedException，而且在被中断的情况下也不会提前返回。   类似地，尝试获取一个内部锁的操作（进入一个 synchronized 块）是不能被中断的，但是 ReentrantLock 支持可中断的获取模式。&lt;/p&gt;
&lt;h3&gt;参考文献：&lt;/h3&gt;
&lt;p&gt;http://stackoverflow.com/questions/671049/how-do-you-kill-a-thread-in-java  &lt;br /&gt;
http://www.ibm.com/developerworks/cn/java/j-jtp05236.html  &lt;br /&gt;
http://stackoverflow.com/questions/3590000/what-does-java-lang-thread-interrupt-do  &lt;br /&gt;
http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#interrupt--  &lt;br /&gt;
http://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>Java中的volatile和synchronized关键字</title><link href="/posts/java_synchronize.html" rel="alternate"></link><updated>2014-02-12T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2014-02-12:posts/java_synchronize.html</id><summary type="html">&lt;p&gt;Java线程同步包括线程之间的交互通信和互斥，线程之间的通信由Java内存模型（JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。Java内存模型的抽象示意图如下：
&lt;img alt="JMM" src="../images/JMM.png" /&gt;
这张图告诉我们，Java线程运行的时候，线程本地内存和主内存之间有一个变量同步的过程，这就导致线程中变量的值何时同步回主内存是不可预期的。
从java源代码到最终实际执行的指令序列，会分别经历下面三种重排序：
&lt;img alt="ReSort" src="../images/ReSort.png" /&gt;&lt;/p&gt;
&lt;p&gt;1属于编译器重排序，2和3属于处理器重排序。可见编译器生成的指令顺序和真正在CPU执行的顺序可能是不一致的。这些重排序都可能会导致多线程程序出现内存可见性问题。
对于编译器优化的重排序，可以通过在Java语言中为变量加上“volatile”强制告诉编译器这个变量一定要从内存获得，这时编译器即不会做此类优化。&lt;/p&gt;
&lt;p&gt;Java内存模型提供了两个关键词“synchronized”和“volatile”，让Java保证某些约束：&lt;/p&gt;
&lt;p&gt;volatile: 保证所有线程读写的都是主内存的变量并且不缓存它，只保证可见性，不保证原子性。关于Volatile的实现原理，可点击&lt;a href="http://www.infoq.com/cn/articles/ftf-java-volatile"&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;synchronized: Java提供的用来支持原子性的内置锁机制，保证在同一时刻，只有一个线程可以执行某个方法或代码块。Java中的每个对象都有一个monitor(锁标记)，当线程拥有这个锁标记时才能访问这个资源。synchronized作用于方法时，锁住的是对象的实例(this)，当作用于静态方法时，锁住的是Class实例，用sychronized修饰的方法或者语句块在代码执行完之后锁自动释放。&lt;/p&gt;
&lt;p&gt;把代码块声明为 synchronized，该代码块就就具有原子性（atomicity和可见性（visibility）。&lt;/p&gt;
&lt;p&gt;原子性: 意味着个时刻，只有一个线程能够执行一段代码，这段代码通过一个monitor 
object保护。从而防止多个线程在更新共享状态时相互冲突。下面举一个线程计数器的例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Counter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码中，由于counter++操作不是原子性的，实际上包含”读取--修改--写入“三个独立的操作，是一个操作序列，所以increment方法并不是线程安全的。当给方法加上synchronized关键字后，Counter类的Class对象会被锁定，这样方法就是线程安全的了。
另一个使得计数器线程安全的例子，是通过使用java.util.concurrent.atomic中的AtomicInteger:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;AtomicCounter&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;AtomicInteger&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AutomicInteger&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;increment&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;counter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getAndIncrement&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可见性: 确保一个线程释放锁之前对共享数据做出的更改对于随后获得该锁的另一个线程是可见的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StopThread&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;stopFlag&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;backgroundThread&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="n"&gt;backgroundThread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;TimeUnit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SECONDS&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的例子，由于没有同步，不能保证后台线程何时看到主线程对stop值所做的改变，导致后台线程永远循环！因此就需要对stop变量进行同步访问控制。
第一种同步方式就是使用synchronized关键字，对stop变量提供同步的读和写方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;StopThread&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setStop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;stop&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;synchronized&lt;/span&gt; &lt;span class="n"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;isStop&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;stop&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;Throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;Thread&lt;/span&gt; &lt;span class="n"&gt;backgroundThread&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="p"&gt;(){&lt;/span&gt;
            &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;isStop&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;});&lt;/span&gt;
        &lt;span class="n"&gt;backgroundThread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;TimeUnit&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;SECONDS&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;setStop&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;第二种同步方式就是将stop变量声明为volatile，这样就保证了任何一个线程在读取该变量值时都将看到最新被写入的值。&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>Maven的依赖管理机制</title><link href="/posts/maven_dependency.html" rel="alternate"></link><updated>2013-12-06T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2013-12-06:posts/maven_dependency.html</id><summary type="html">&lt;p&gt;&lt;a href="http://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#System_Dependencies"&gt;依赖管理&lt;/a&gt;是Maven的一项强大功能，在单模块的项目中使用依赖管理相当简单，但是大项目一般会分成几个子项目，每个子项目就会有自己的POM 文件，然后它们会有一个共同的父项目，这样在管理多模块的大项目时，弄清楚模块间的依赖管理机制，对维护整个项目稳定性就显得相当重要了。&lt;/p&gt;
&lt;p&gt;这里首先介绍一下Maven中坐标的概念，在POM中，groupId, artifactId, packaging, version 叫作 Maven 坐标，它能唯一的确定一个项目，因此我们可以用它来解决依赖关系。
Maven的依赖管理机制包括以下三个方面：
&lt;ul&gt;
    &lt;li&gt;依赖传递&lt;/li&gt;
    &lt;li&gt;依赖管理&lt;/li&gt;
    &lt;li&gt;依赖范围&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;h2&gt;依赖传递&lt;/h2&gt;
&lt;p&gt;这是Maven2.0的一个新特性，指的是说依赖能够自动继承和传递，类似于yum和apt-get等linux的包管理机制，自动解析依赖关系。例如module A依赖module B的artifact b，而module B依赖于module C的artifact c，那么在build module A时，A的依赖中就会自动出现B和C。
由于这种可传递的依赖，会导致两个问题：
&lt;ul&gt;
    &lt;li&gt;依赖树变得很庞大&lt;/li&gt;例如A -&amp;gt; B -&amp;gt; C -&amp;gt; D -&amp;gt; E...
    &lt;li&gt;出现死循环依赖&lt;/li&gt;例如A -&amp;gt; B -&amp;gt; C -&amp;gt; D -&amp;gt; B
&lt;/ul&gt;
因此，还需要其它方式来限制要包括的依赖。&lt;/p&gt;
&lt;h2&gt;依赖管理&lt;/h2&gt;
&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;依赖调停 &lt;/li&gt;
    这是为了解决在依赖树上当同一个artifact出现多个版本时的版本选择问题。目前，Maven2.0只支持"nearest definition"，即近亲原则，而不是不是以version越大越保留，就是说选择在依赖树里最靠近你的项目的artifact版本。
    例如当出现：A -&amp;gt; B -&amp;gt; C -&amp;gt; D 2.0和A -&amp;gt; E -&amp;gt; D 1.0, 那么D的1.0版本将会被使用，因为从A通过E到达D的路径是最短的。这种情况下，如果硬是要A使用D的2.0版本,可以在A里显式设置对D的依赖版本为2.0。
    如果依赖深度一样时则按出现的顺序选择，例如A -&amp;gt; B -&amp;gt; C1.0， A -&amp;gt; D -&amp;gt; C2.0,那么在Maven2.0.9版本之后依照“先到先得”原则，出现在前面的C1.0将被选择。
    &lt;li&gt;依赖管理&lt;/li&gt;
    依赖管理就是在POM文件里添加&lt;dependencyManagement&gt;元素,并在里面设置要使用的depedency的版本号，这样dependencyManagement里面定义的版本号就会优先于依赖调停 的版本号，
    可以通过mvn dependency:tree来查看项目依赖。
    &lt;li&gt;依赖排除&lt;/li&gt;
    如果X -&amp;gt; Y -&amp;gt; Z，可以在X的exclusion元素中声明不依赖Z。
    例如当出现A-&amp;gt;B-&amp;gt;C-&amp;gt;D-&amp;gt;B依赖死循环时，就可以在D的exclusion元素中声明不依赖B。
&lt;/ul&gt;&lt;/p&gt;
&lt;h2&gt;依赖范围&lt;/h2&gt;
&lt;p&gt;依赖范围注意用于限制依赖传递和管理依赖的部署。目前有以下6个范围值：
&lt;ul&gt;
    &lt;li&gt;compile&lt;/li&gt;默认值，在编译的时候需要什么依赖就给你添加什么jar，jar包会随着项目一起发布。
    &lt;li&gt;provided&lt;/li&gt;期望JDK、容器或使用者会提供这个依赖，发布的时候不包含该jar，这种scope的jar不会被传递。
    &lt;li&gt;runtime&lt;/li&gt;只在运行时使用，如JDBC驱动，适用运行和测试阶段。
    &lt;li&gt;test&lt;/li&gt;只在测试时使用，用于编译和运行测试代码。不会随项目发布。
    &lt;li&gt;system&lt;/li&gt;类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它，需要指定&lt;systemPath&gt;查找路径。
    &lt;li&gt;import&lt;/li&gt;用于从dependencyManagement中导入依赖。 
&lt;/ul&gt;&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>JAX-WS-WebService开发入门</title><link href="/posts/jax_webservice.html" rel="alternate"></link><updated>2013-10-01T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2013-10-01:posts/jax_webservice.html</id><summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;遵循&lt;a href="https://jcp.org/aboutJava/communityprocess/final/jsr224/index.html"&gt;JCP JAX-WS 2.0 API&lt;/a&gt;规范，可以按照以下步骤进行WebService开发
&lt;ul&gt;
  &lt;li&gt;定义服务端点接口类（Server Endpoint Interface）&lt;/li&gt;
  &lt;li&gt;给接口添加注解&lt;/li&gt;
  &lt;li&gt;发布webserive服务&lt;/li&gt;
  &lt;li&gt;开发客户端&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;h2&gt;SEI(Server Endpoint Interface)定义&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;demo&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;
&lt;span class="cp"&gt;#定义POJO接口&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;OrderProcess&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;processOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cp"&gt;#OrderProcessImpl实现接口processOrder的方法, 作为Webservice方法暴露&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;OrderProcessImpl&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;OrderProcess&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;processOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Processing order...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;validate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;orderID&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;添加WebService注解&lt;/h2&gt;
&lt;p&gt;基于 XML 的 Web Service 的 Java API&lt;a href="http://pic.dhe.ibm.com/infocenter/wasinfo/v6r1/index.jsp?topic=%2Fcom.ibm.websphere.wsfep.multiplatform.doc%2Finfo%2Fae%2Fae%2Frwbs_jaxwsannotations.html&amp;amp;lang%3Dzh_CN"&gt;（JAX-WS）&lt;/a&gt;通过使用注释来指定与 Web Service 实现相关联的元数据以及简化 Web Service 的开发。通过使用符合 JSR 181 标准的注释，可以简单地注释服务实现类或服务接口，将应用程序作为 Web Service 来启用。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;javax&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jws&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WebService&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;WebService&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;interface&lt;/span&gt; &lt;span class="n"&gt;OrderProcess&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;processOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;WebService&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;endpointInterface&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;com.demo.order.OrderProcess&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;serviceName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;OrderProcessService&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;portName&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;OrderProcessPort&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;OrderProcessImpl&lt;/span&gt; &lt;span class="n"&gt;implements&lt;/span&gt; &lt;span class="n"&gt;OrderProcess&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;processOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Processing order...&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;orderID&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;validate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;orderID&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;ul&gt;
&lt;li&gt;endpointInterface指定用于定义服务的抽象 Web Service 约定的服务端点接口的限定名，非必须。&lt;/li&gt;
&lt;li&gt;serviceName指定 Web Service 的服务名称：wsdl:service。用作客户端用户获取远端接口存根，调用服务方法。缺省值为 Java 类的简单名称 + Service。&lt;/li&gt;
&lt;li&gt;portName指定服务端点的名称：wsdl:portName。缺省值为 WebService.name+Port。&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;
&lt;h2&gt;发布服务&lt;/h2&gt;
&lt;p&gt;发布服务就是将Webservice服务组件注册到服务器中，之后客户端就可以通过endpoint URL访问该Webservice服务了。OrderProcess将通过一个唯一的endpoint URL（例如http://localhost:8080/OrderProcess） 发布服务。这里使用Java 5提供的轻量级web server作为例子。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;import&lt;/span&gt; &lt;span class="n"&gt;javax&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;xml&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ws&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Endpoint&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;protected&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Starting Server&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;OrderProcessImpl&lt;/span&gt; &lt;span class="n"&gt;orderProcessImpl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;OrderProcessImpl&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
       &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://localhost:8080/OrderProcess&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
       &lt;span class="n"&gt;Endpoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;publish&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;address&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;orderProcessImpl&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Server&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sleep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;50000&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt; 
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Web Service创建成功之后，就可以查看通过 http://localhost:8080/OrderProcess?wsdl 查看服务的WSDL文档了。&lt;/p&gt;
&lt;h2&gt;开发客户端&lt;/h2&gt;
&lt;p&gt;客户端调用Webservice方法获得结果。下面的代码开发了一个客户端类调用OrderProcess Webservice的processOrder方法。 &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
   &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;QName&lt;/span&gt; &lt;span class="n"&gt;SERVICE_URI&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://order.demo.com/&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;QName&lt;/span&gt; &lt;span class="n"&gt;SERVICE_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SERVICE_URI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;OrderProcessService&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;QName&lt;/span&gt; &lt;span class="n"&gt;PORT_NAME&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;QName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SERVICE_URI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;OrderProcessPort&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
   &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="n"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;WSDL_LOCATION&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;http://localhost:8080/OrderProcess?wsdl&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
   &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt; &lt;span class="n"&gt;throws&lt;/span&gt; &lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
       &lt;span class="n"&gt;URL&lt;/span&gt; &lt;span class="n"&gt;wsdlURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;URL&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WSDL_LOCATION&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;Service&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Service&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;wsdlURL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SERVICE_NAME&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;OrderProcess&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getPort&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;PORT_NAME&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
       &lt;span class="n"&gt;OrderProcess&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;Order&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Order&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
       &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setCustomerID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;C001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setItemID&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;I001&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setPrice&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;100.00&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;setQty&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;20&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;processOrder&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;order&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
       &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;out&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;The order ID is &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="err"&gt;￼&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从客户端代码可以注意到，
&lt;ul&gt;
  &lt;li&gt;QName SERVICE_URI对应于服务端的targetNamespace(默认是包名反转)&lt;/li&gt;
  &lt;li&gt;QName SERVICE_NAME对应于服务端的serviceName &lt;/li&gt;
  &lt;li&gt;QName PORT_NAME对应于服务端的portName&lt;/li&gt;
&lt;/ul&gt;&lt;/p&gt;</summary><category term="Java"></category></entry><entry><title>Solr使用入门</title><link href="/posts/sorl_study.html" rel="alternate"></link><updated>2013-09-02T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2013-09-02:posts/sorl_study.html</id><summary type="html">&lt;p&gt;&amp;emsp;&amp;emsp;大多数应用程序的数据都是存数在数据库上的，再由前端发起请求向数据库发起查询请求获取数据。当我们需要从大量数据中进行全文检索时，由于数据库索引不是为全文索引设计的，因此，使用like "%keyword%"时，数据库索引是不起作用的，特别是对模糊查询的数据库服务来说，like查询对性能的危害是极大的。因此，我们需要像Solr这样的支持全文索引的索引引擎来完成这项功能。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;Apache Solr (读音: SOLer) 是一个开源的搜索服务器，使用 Java 语言开发，主要基于 HTTP 和 Apache Lucene实现。Solr 需要运行在一个servlet容器里如Jetty或Tomcat，并提供了一个基于Http的Web Service的接口进行交互。&lt;/p&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;下面介绍如何使用Solr搭建自己的全文检索。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从官网 (http://lucene.apache.org/solr/) 下载最新版本，solr的发布包包含了一个example，其中附带了一个jetty以便我们快速搭建一个可运行的solr示例，所以只需几行简单的命令将solr跑起来：    &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;cd&lt;/span&gt; &lt;span class="n"&gt;solr&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;
&lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;jar&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;访问http://localhost:8983/solr/admin/ 即可看到solr的主页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标准安装，将solr安装到tomcat，修改tomcat端口避免与web应用冲突，并将编码改为UTF-8：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Connector&lt;/span&gt; &lt;span class="n"&gt;port&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8983&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;protocol&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;HTTP/1.1&amp;quot;&lt;/span&gt;
        &lt;span class="n"&gt;connectionTimeout&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;20000&amp;quot;&lt;/span&gt;            
        &lt;span class="n"&gt;redirectPort&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;8443&amp;quot;&lt;/span&gt; &lt;span class="n"&gt;URIEncoding&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;UTF-8&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;/&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找到apache-solr-4.x.x/dist/apache-solr-4.x.x.war包，复制到tomcat的webapps目录下并修改名字为solr,然后直接启动tomcat，此时tomcat报错，说找不到solrconfig.xml。&lt;/p&gt;
&lt;p&gt;这是因为solr的平台与配置是相互分离的，我们复制的war包在启动的时候，solr找不到solr.home的配置。解决办法是到tomcat/webapps/solr/WEB-INF/web.xml中，找到一段注释的代码，修改起solr home位置： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;env-entry&amp;gt;&lt;/span&gt;                                                                                                                                                                                 &lt;span class="nt"&gt;&amp;lt;env-entry-name&amp;gt;&lt;/span&gt;solr/home&lt;span class="nt"&gt;&amp;lt;/env-entry-name&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;env-entry-value&amp;gt;&lt;/span&gt;apache-solr-4.0.0/example/solr&lt;span class="nt"&gt;&amp;lt;/env-entry-value&amp;gt;&lt;/span&gt;                                                                                                                                                                                                                                                                                                                     
&lt;span class="nt"&gt;&amp;lt;env-entry-type&amp;gt;&lt;/span&gt;java.lang.String&lt;span class="nt"&gt;&amp;lt;/env-entry-type&amp;gt;&lt;/span&gt;                                                                      
&lt;span class="nt"&gt;&amp;lt;/env-entry&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;观察这个指定的solr.home位置，其collection1目录下存在两个文件夹：conf和data。                                                            &lt;br /&gt;
其中conf里存放了对solr而言最为重要的两个配置文件schema.xml和solrconfig.xml。                                                           data则用于存放索引文件。  &lt;br /&gt;
                                                                                                                                                                   schema.xml主要包括types、fields和其他的一些缺省设置。  &lt;br /&gt;
                                                                                                                                                                                                                      solrconfig.xml用来配置Solr的一些系统属性，例如与索引和查询处理有关的一些常见的配置选项，以及缓存、扩展等等。   &lt;br /&gt;
                                                                                                                                                                                                                                                                                                                                                                               注意到schema.xml里有一个&lt;uniqueKey &gt; url&lt;/uniqueKey&gt; 的配置，这里将url字段作为索引文档的唯一标识符，非常重要。 &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动tomcat，在linux下运行并打开： http://localhost:8983/solr/admin/ &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;catalina&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;sh&lt;/span&gt; &lt;span class="n"&gt;run&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在schema.xml中自定义索引结构。&lt;/p&gt;
&lt;p&gt;将所有field和dynamicField删除，换成自己的索引字段，最后fields结构如下：&lt;/p&gt;
&lt;p&gt;其中name为"text" 和"_version"的field 必须有！  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;fields&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;string&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt; 
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text_general&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text_general&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;content&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text_general&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;author&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text_general&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;date&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;multiValued=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;false&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;

   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;text_general&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;false&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;multiValued=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;_version_&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;long&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;indexed=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt; &lt;span class="na"&gt;stored=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;true&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
  &lt;span class="nt"&gt;&amp;lt;/fields&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试。在solr/example/exampledoc 创建两个 xml 数据文件，分别保存为 demo-doc1.xml 和 demo-doc2.xml：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;&lt;/span&gt;  
       &lt;span class="nt"&gt;&amp;lt;add&amp;gt;&lt;/span&gt;  
           &lt;span class="nt"&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;  
                    &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
                    &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;wukaibin&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;

                    &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;solr 应用演讲&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
                    &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;这一小节是讲提交数据给服务器做索引&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
                   &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;solr 应用演讲&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
           &lt;span class="nt"&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;  
       &lt;span class="nt"&gt;&amp;lt;/add&amp;gt;&lt;/span&gt;

&lt;span class="cp"&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;UTF-8&amp;quot; ?&amp;gt;&lt;/span&gt;  
       &lt;span class="nt"&gt;&amp;lt;add&amp;gt;&lt;/span&gt;  
           &lt;span class="nt"&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;  
              &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;2&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;czx&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;体育运动&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;你喜欢打羽毛球吗&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;solr 应用演讲&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
                &lt;span class="nt"&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;  
           &lt;span class="nt"&gt;&amp;lt;doc&amp;gt;&lt;/span&gt;
              &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;id&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;3&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;    
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;author&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;lcc&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;title&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;netease&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
               &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;content&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;你玩游戏吗&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
              &lt;span class="nt"&gt;&amp;lt;field&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;description&amp;quot;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;solr 应用演讲&lt;span class="nt"&gt;&amp;lt;/field&amp;gt;&lt;/span&gt;  
           &lt;span class="nt"&gt;&amp;lt;/doc&amp;gt;&lt;/span&gt;  
       &lt;span class="nt"&gt;&amp;lt;/add&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后在exampledoc目录下运行以下命令向solr提交数据作索引：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;java&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;Durl&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="c1"&gt;//localhost:8983/solr/update -Dcommit=yes -jar post.jar demo-doc*.xml&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;提交成功后即可查看搜索结果，以下url即是查看所有内容：     &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//localhost:8983/solr/select/?q=*%3A*&amp;amp;version=2.2&amp;amp;start=0&amp;amp;rows=10&amp;amp;indent=on&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除solr中的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nl"&gt;http:&lt;/span&gt;&lt;span class="c1"&gt;//localhost:8983/solr/update?stream.body=%3Cdelete%3E%3Cquery%3E*:*%3C/query%3E%3C/delete%3E&amp;amp;commit=true&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;参考链接：&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;http://blog.chenlb.com/2009/05/apache-solr-quick-start-and-demo.html&lt;/li&gt;
&lt;li&gt;http://www.blogjava.net/RongHao/archive/2007/11/06/158621.html&lt;/li&gt;
&lt;li&gt;http://www.aidansu.com/blog/1361.html&lt;/li&gt;
&lt;li&gt;http://blog.csdn.net/yangaming/article/details/8197241&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Java"></category></entry><entry><title>理解Java语言的几张图</title><link href="/posts/java_pictures.html" rel="alternate"></link><updated>2013-07-06T00:00:00+08:00</updated><author><name>Kaibin</name></author><id>tag:,2013-07-06:posts/java_pictures.html</id><summary type="html">&lt;h2&gt;Java 体系结构图&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Java Topic" src="images/Java_Topic.png" /&gt;&lt;/p&gt;
&lt;h2&gt;Java &lt;a href="http://www.programcreek.com/2009/02/diagram-for-hierarchy-of-exception-classes/"&gt;异常类层次&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;红色的方块为 Checked Exception，必须被捕获或者是在方法中使用 throws 声明抛出。
&lt;img alt="Throwable" src="images/Throwable.jpeg" /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://www.programcreek.com/2009/02/the-interface-and-class-hierarchy-for-collections/"&gt;集合类层次&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Collection" src="images/Collection.jpeg" /&gt;
&lt;img alt="Map" src="/images/Map.jpg" /&gt;&lt;/p&gt;
&lt;h2&gt;&lt;a href="http://www.programcreek.com/2013/04/jvm%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"&gt;JVM运行时的数据区&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img alt="Memory" src="images/Memory.jpg" /&gt;&lt;/p&gt;</summary><category term="Java"></category></entry></feed>